## 1. 引言

### 1.1. 编写目的

该合约旨在提供一个普适性的合规审计方案，能够事先于智能合约中自定义在审计过程中的一系列检查项，使得事务执行者能够在规则约束下”合法“参与。

### 1.2. 背景

目前的区块链落地主要基于区块链不可篡改的属性应用于存证、溯源等场景，而不可窜改性事实上是第一代区块链（如比特币）已经具备的，如何能够基于智能合约为各行业赋能是区块链应用面临的一个重大课题。

在做业务探索时我们按如下思路思考：运行于区块链虚拟机上的智能合约是区块链账本所承载的信任的自然传递，而连接链上与链下的桥梁——预言机服务可以看做是区块链的”眼睛“。如果能事先定义好规则让预言机服务实时”看到“现实世界中的事务，根据人们的行为智能决策并将这些行为以不可篡改的事件形式记录在区块链上，就能形成”事前定义“、”事中监控“、”事后问责“的完整业务闭环。

在银行中存在这样一个真实业务场景，银行的某些工作人员需要在固定的时间周期（如：每个月两次）去核算、检查与各商户的POS机业务情况。但银行无法确定其工作人员是否去现场真实执行该业务，尽管随着通信技术的发展可以要求工作人员拍摄到场视频等作为佐证，但业务中可操作性很大难以保证工作人员造假，而且还存在工作人员与业务流程管理员串通修改风险。

如果将合规审计方案应用到改POS审计场景，我们可以准备用于验证时间、地点、人脸识别以及物体识别等预言机服务，并事先定义规则以限定时间（如：工作日的上班时间）、地点（如指定商户坐标的1千米范围内）、须本人操作（通过人脸识别服务与预先录入的该工作人员的人脸特征信息进行比对验证）且识别到指定类型的POS机（通过物体识别服务与预先录入的POS机型特征信息进行比对验证）等约束条件，并注册到审计智能合约中。这样当银行工作人员执行该业务时，会在审计智能合约中登记审计事件，只有符合上述左右约束条件才能验证成功。可以看到我们应用区块链技术不仅有效监督银行业务人员现场的业务执行情况，而且利用区块链不可篡改的属性防止银行内部人员传统作假，并建立起可靠的事后问责机制。

在本次提交的智能合约实现中，我们设计了可应用于所有合规审计业务的普适性方案，并针对上述银行业务场景中所需的预言机服务以及规则方案做了细化。其他的审计场景可以视具体业务做类似的细化实现。

### 1.3. 定义

- **合约运维人员（maintainer）**：保障合约正常运转的运维人员，具有录入审计当事人、规则、规则方案、项目等信息的权限
- **审计当事人（auditee）**：审计业务中的执行人员，如上文提到的银行工作人员
- **规则（rule）**：用于定义一项具体的约束验证，规则会有类别，若验证需要涉及与区块链无关的上下文，一般情况下该类规则会对应一个预言机服务
- **规则方案（rule schema）**：由一个或多个规则组成，用于表达审计当事人在某个具体业务场景下需要验证的所有规则
- **项目（project）**：定义一个具体的业务，并包含该业务中所涉及的所有审计当事人以及规则方案。当然我们将不同的业务部署在不同的智能合约中，这里抽象出项目的概念是为了复用审计当事人以及规则方案等，为业务实现人员提供便利
- **合规事件（event）**：定义审计当事人的一次具体的业务执行记录

## 2. 数据存储环境说明

合规审计业务涉及的数据存储可分为链上和链下存储两个部分：

### 2.1. 链上存储

由于该审计方案在多个联盟链上编写，为了统一存储方式，所有的链上数据存储均采用键值存储的方式。

Fabric和XuperChain在智能合约上下文中都提供了键值存储的接口，在这两个联盟链的智能合约实现中，我们一般使用Key值存储一个对象的ID，而Value值用于存储对象本身。考虑到对象信息的可读性，我们采用了JSON序列化的方式存储。

目前在CITA和FISCO BCOS平台都使用solidity语言开发，两个平台上数据存储统一使用solidity原生的`mapping`存储，考虑到平台之间的统一性我们未在FISCO BCOS平台使用Table存储数据。与Fabric和XuperChain类似，我们使用Key值存储一个对象的ID，而Value值用于存储对象本身。

### 2.2. 链下存储

当我们注册规则时需要给定规则约束条件，这些约束条件会在注册规则项时传入或者在构建预言机服务的时候内置于其中，而上述约束条件以及对应的规则ID映射关系都存储于预言机服务附带的存储中。

## 3. 数据结构的命名规则

这里先给出代码中用到的命名规则说明：

- **蛇形命名**：所有单词小写，单词与单词之间使用下划线分割，如`snak_style`
- **首字母大写驼峰命名**：所有单次的首字母都大写，如`CamleStyle`
- **首字母小写驼峰命名**：首字母小写，随后的单词首字母大写，如`camleStyle`
- **所有字母大写**：如`CAMLESTYLE`

目前Fabric和XuperChain平台上的智能合约通过go语言实现，而CITA和FISCO BCOS平台使用solidity语言开发，为了保持所有平台之间语言风格的一致性且不破坏不同语言固有的命名规则，定义命名规则如下：

### 3.1. go语言命名规则

#### 3.1.1 目录管理

go语言目录组织符合GOPATH组织规范，所有源码文件位于src目录下。目录名使用蛇形命名法。

src下的core子目录用于存储Fabric和XuperChain平台的共有逻辑，而平台相关的逻辑分别存储在fabric和xchain子目录内。

#### 3.1.2. 包管理

考虑到fabric1.4版本对go mod并未很好地支持，我们在go语言开发中采用GOPATH方式进行包管理。为了方便代码阅读我们在导入智能合约的内部包时使用了相对路径，而引入Fabric和XuperChain平台相关依赖时使用了绝对路径的方式。

这就要求我们在构建合约时不仅引入全局GOPATH，而且要将源码所在的目录作为GOPATH路径导入。不过我们为Fabric和XuperChain平台分别编写了Makefile脚本，使用make命令时无须手动设置GOPATH路径。

#### 3.1.3. 文件命名

文件名一律使用蛇形命名法，与go语言对单元测试文件的命名要求保持一致。

#### 3.1.4. 结构体命名

- 包内定义的结构体使用首字母小写驼峰命名法
- 需要在包外使用的结构体使用首字母大写驼峰命名法

#### 3.1.5. 函数命名

- 仅在包内使用的函数使用首字母小写驼峰命名法
- 需要在包外使用的函数使用首字母大写驼峰命名法

#### 3.1.6. 变量命名

- 仅在包内使用的全局变量使用首字母小写驼峰命名法
- 需要在包外使用的全局变量使用首字母大写驼峰命名法
- 通过const变量模拟枚举（Enum）的变量采用所有字母大写的命名方式
- 函数参数变量、本地变量使用首字母小写驼峰命名法，为了符合go语言的命名习惯，应尽量使用短小的变量名

### 3.2. solidity语言命名规则

#### 3.2.1 目录管理

考虑到FISCO BCOS合约部署的便捷性，我们在使用solidity语言开发时采用了尽量扁平化的目录组织方式，目前除了用于存放通用接口的子目录interface之外，其他文件都直接存放在其所属的智能合约目录下。

#### 3.2.2. 文件命名

文件名使用首字母大写驼峰命名法，这样与合约名保持一致为合约部署带来便利。

#### 3.2.3. 合约命名

合约名使用首字母大写驼峰命名法。

#### 3.2.4. 结构体命名

结构体名使用首字母大写驼峰命名法。

#### 3.2.5. 方法命名

方法名使用首字母小写驼峰命名法，与构造方法命名规则保持一致。

#### 3.2.6. 变量命名

- 结构体中的成员变量使用首字母大写驼峰命名法
- 其他变量一律使用首字母小写驼峰命名法

## 4. 安全性设计

CA认证

权限设计

有效性验证

## 5. 优化

| 优化对象（目标） | 措施 | 效果 |
| ---------------- | ---- | ---- |
|                  |      |      |
|                  |      |      |
|                  |      |      |

## 6. 数据结构设计

